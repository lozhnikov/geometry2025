/*!

@file algorithms/dimcirus.dox
@author Dmitrii Chebanov

@page dimcirus Отсечение отрезка выпуклым полигоном (метод Димикуса)
@section overview Обзор

Алгоритм Димикуса предназначен для отсечения отрезка относительно выпуклого полигона. 
Результатом работы является часть исходного отрезка, лежащая внутри полигона, 
либо индикация того, что отрезок полностью вне полигона.

Основные сценарии:
- Отрезок полностью внутри полигона — возвращается исходный отрезок.
- Отрезок полностью снаружи — возвращается флаг success: false.
- Отрезок пересекает полигон — возвращаются точки входа и выхода.

@section complexity Сложность
- Временная сложность: O(N), где N — количество рёбер полигона.
- Память: O(1) (не требуется дополнительных структур данных).

@section implementation Реализация
Основные этапы работы:
1. Инициализация параметров t0 = 0 и t1 = 1, задающих диапазон видимой части отрезка.
2. Для каждого ребра полигона:
   - Вычисление пересечения отрезка с ребром.
   - Обновление t0 для входящих пересечений и t1 для выходящих.
3. Если t0 <= t1, отрезок видим — возвращаются точки s(t0) и s(t1).

@subsection details Детали реализации
1. Классификация пересечений
   - Skew: Отрезок пересекает ребро. Определяется вхождение/выхождение по знаку скалярного произведения.
   - Parallel/Collinear: Отрезок параллелен ребру. Проверяется положение начала отрезка относительно полигона.

2. Вектор нормали ребра
   - Для определения направления используется повёрнутое ребро (на 90°), 
   чей вектор задаёт нормаль к грани полигона.

3. Параметрическое представление отрезка
   - Отрезок задаётся как s(t) = origin + t * direction, где t ∈ [0, 1].

@section examples Примеры использования
@code{.json}
// Пример 1: Отрезок внутри полигона
{
  "id": 1,
  "type": "float",
  "segment": {
    "origin": { "x": 1.0, "y": 1.0 },
    "destination": { "x": 2.0, "y": 2.0 }
  },
  "polygon": {
    "vertices": [
      { "x": 0.0, "y": 0.0 },
      { "x": 3.0, "y": 0.0 },
      { "x": 3.0, "y": 3.0 },
      { "x": 0.0, "y": 3.0 }
    ]
  }
}

// Ответ:
{
  "success": true,
  "id": 1,
  "type": "float",
  "result": {
    "origin": { "x": 1.0, "y": 1.0 },
    "destination": { "x": 2.0, "y": 2.0 }
  }
}

// Пример 2: Отрезок снаружи полигона
{
  "id": 2,
  "type": "float",
  "segment": {
    "origin": { "x": -1.0, "y": -1.0 },
    "destination": { "x": -2.0, "y": -2.0 }
  },
  "polygon": { ... } // Тот же полигон
}

// Ответ:
{
  "success": false,
  "id": 2,
  "type": "float"
}

// Пример 3: Отрезок пересекает полигон
{
  "id": 3,
  "type": "double",
  "segment": {
    "origin": { "x": -1.0, "y": 1.0 },
    "destination": { "x": 4.0, "y": 1.0 }
  },
  "polygon": { ... } // Тот же полигон
}

// Ответ:
{
  "success": true,
  "id": 3,
  "type": "double",
  "result": {
    "origin": { "x": 0.0, "y": 1.0 },
    "destination": { "x": 3.0, "y": 1.0 }
  }
}
@endcode

@section limitations Ограничения
- Полигон должен быть выпуклым. Для невыпуклых полигонов результат не гарантируется.
- Точность вычислений ограничена значением 1e-6 (используется для сравнений с плавающей точкой).
*/